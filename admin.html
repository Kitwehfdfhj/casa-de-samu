<!doctype html>
<html lang="es" dir="ltr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title id="pageTitle">Panel de AdministraciÃ³n â€” Salas de usuarios</title>
<style>
  body{font-family:"Cairo",sans-serif;margin:0;background:linear-gradient(135deg,#0f172a,#1e293b);min-height:100vh;color:#fff}
  #container{display:flex;gap:18px;max-width:1100px;margin:22px auto;padding:18px}
  #left{width:340px;background:rgba(255,255,255,0.03);border-radius:12px;padding:14px}
  #right{flex:1;background:rgba(255,255,255,0.03);border-radius:12px;padding:14px;display:flex;flex-direction:column;height:80vh}
  h3{margin:4px 0 8px 0}
  .userItem{display:flex;align-items:center;justify-content:space-between;padding:10px;border-bottom:1px solid rgba(255,255,255,0.03);cursor:pointer;position:relative}
  .userItem:hover{background:rgba(255,255,255,0.02)}
  .userLeft{display:flex;gap:10px;align-items:center}
  .online-dot{width:10px;height:10px;border-radius:50%;background:#00ff44}
  .offline-dot{width:10px;height:10px;border-radius:50%;background:#777}
  .userMeta{display:flex;flex-direction:column}
  .lastSeen{font-size:11px;color:#9aa4b2}
  .badge-unread{background:#ef4444;color:white;border-radius:12px;padding:3px 8px;font-size:12px;margin-left:8px}
  #messagesArea{flex:1;overflow:auto;padding:8px;border-radius:8px;background:rgba(0,0,0,0.06)}
  .msg{margin-bottom:10px;padding:10px;border-radius:8px;background:rgba(255,255,255,0.03)}
  .msg.admin{background:rgba(59,130,246,0.08);text-align:left}
  .msg .who{font-size:13px;color:#0ea5a2;margin-bottom:6px;display:block}
  #adminControls{display:flex;gap:8px;margin-top:8px}
  textarea{width:100%;height:80px;border-radius:8px;padding:8px;border:none;background:rgba(255,255,255,0.04);color:white;resize:none}
  button{padding:10px 14px;border-radius:8px;border:none;background:#2563eb;color:white;cursor:pointer}
  button.clear{background:#ef4444}
  .meta{font-size:12px;color:#cbd5e1}
  .smallMuted{font-size:12px;color:#9aa4b2}
</style>
</head>
<body>

<!-- Audio para notificaciÃ³n -->
<audio id="msgSound">
  <source src="https://assets.mixkit.co/sfx/preview/mixkit-message-pop-alert-2354.mp3" type="audio/mpeg">
</audio>

<!-- Contenedor -->
<div id="container">
  <div id="left">
    <h3>Lista de usuarios</h3>
    <div id="usersList" style="max-height:76vh;overflow:auto"></div>
  </div>

  <div id="right">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div>
        <h3 id="roomTitle">Selecciona un usuario para ver su sala</h3>
        <div id="roomSub" class="meta"></div>
      </div>
      <div>
        <button id="logoutBtn">Salir</button>
      </div>
    </div>

    <div id="messagesArea"></div>

    <div id="typingIndicator" style="color:#00eaff;height:20px;margin-top:6px"></div>

    <div id="adminControls">
      <textarea id="adminReply" placeholder="Escribe la respuesta de la AdministraciÃ³n..."></textarea>
      <div style="display:flex;flex-direction:column;gap:8px">
        <button id="sendReplyBtn">Enviar respuesta</button>
        <button id="clearRoomBtn" class="clear">Borrar sala</button>
      </div>
    </div>
  </div>
</div>

<script type="module">
/*
  admin.html (ES)
  - Funcionalidades aÃ±adidas:
    1) unread count por usuario (en DB: unread/{uid}/count)
    2) lastSeen se muestra desde users/{uid}.lastSeen (se espera que cliente actualice Ù‡Ø°Ø§)
    3) service worker registration + show notifications incluso Ø¹Ù†Ø¯Ù…Ø§ pagina en bg (para push se necesita FCM/server)
    4) notificaciÃ³n + sonido + badge en tÃ­tulo + contador global de no leÃ­dos
*/

import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-app.js";
import { getDatabase, ref, set, push, onValue, remove, get, child, runTransaction } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-database.js";

const firebaseConfig = {
  apiKey: "AIzaSyCiMs-fSIJi1Jwi6_BSddsmCZ5GXatdcEA",
  authDomain: "casa-7bc46.firebaseapp.com",
  databaseURL: "https://casa-7bc46-default-rtdb.firebaseio.com",
  projectId: "casa-7bc46",
  storageBucket: "casa-7bc46.firebasestorage.app",
  messagingSenderId: "464116381670",
  appId: "1:464116381670:web:03d98f8aeea6769d4b8827"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);

/* DOM */
const usersList = document.getElementById("usersList");
const roomTitle = document.getElementById("roomTitle");
const roomSub = document.getElementById("roomSub");
const messagesArea = document.getElementById("messagesArea");
const adminReply = document.getElementById("adminReply");
const sendReplyBtn = document.getElementById("sendReplyBtn");
const typingIndicator = document.getElementById("typingIndicator");
const clearRoomBtn = document.getElementById("clearRoomBtn");
const logoutBtn = document.getElementById("logoutBtn");
const audio = document.getElementById("msgSound");
const pageTitle = document.getElementById("pageTitle");

let selectedUserId = null;
let selectedUserName = null;
let swRegistration = null;
let unreadListeners = {}; // listeners for onChildAdded per user
let lastMessageTimestamp = 0;

/* Register service worker (SW) to enable notifications + background when using FCM */
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js').then(reg => {
    console.log('Service Worker registrado', reg);
    swRegistration = reg;
  }).catch(err => {
    console.warn('No se pudo registrar Service Worker:', err);
  });
}

// Solicitar permiso de notificaciones al cargar
if (Notification.permission !== "granted") {
  Notification.requestPermission();
}

/* ---------- FUNCIONES DE NOTIFICACIÃ“N ---------- */

let flashing = false;
function startFlash(badgeCount = 0){
  if(flashing) return;
  flashing = true;
  const original = document.title;
  let toggle = false;
  const interval = setInterval(()=>{
    if(!flashing){ clearInterval(interval); document.title = original; return; }
    document.title = toggle ? `ðŸ“© (${badgeCount}) Nuevos mensajes` : original;
    toggle = !toggle;
  }, 700);
}
function stopFlash(){ flashing = false; }

function showDesktopNotification(title, body){
  if(Notification.permission === "granted"){
    // si SW estÃ¡ registrado, pedir Ù„Ù‡ Ø¹Ø±Ø¶ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±
    if(swRegistration && swRegistration.showNotification){
      try{
        swRegistration.showNotification(title, {
          body,
          icon: "https://cdn-icons-png.flaticon.com/512/889/889140.png",
          tag: 'chat-notif'
        });
      } catch(e){ 
        // fallback
        new Notification(title, { body, icon: "https://cdn-icons-png.flaticon.com/512/889/889140.png" });
      }
    } else {
      new Notification(title, { body, icon: "https://cdn-icons-png.flaticon.com/512/889/889140.png" });
    }
  }
}

// reproducir sonido
function playSound(){ 
  try{ audio.currentTime = 0; audio.play(); } catch(e){} 
}

/* ---------- LÃ“GICA DE LISTA DE USUARIOS / UNREAD / LASTSEEN ---------- */

/*
  Estructura en la DB esperada:
  - users/{uid} => { name, online: true/false, lastSeen: timestamp }
  - chatMessages/{uid}/{msgId} => { text, from: "user"|"admin", name, timestamp }
  - unread/{uid}/count => number
*/

const usersRef = ref(db, "users");

// leer lista de usuarios y construir UI
onValue(usersRef, (snap) => {
  usersList.innerHTML = "";

  snap.forEach(child => {
    const u = child.val() || {};
    const id = child.key;

    // crear elemento si Ù„Ø§ Ù…ÙˆØ¬ÙˆØ¯
    const div = document.createElement("div");
    div.className = "userItem";
    div.id = `user-${id}`;

    // obtener unread count (lo leeremos en paralelo y actualizaremos)
    // tambiÃ©n mostraremos lastSeen si existe
    const lastSeen = u.lastSeen ? new Date(u.lastSeen).toLocaleString() : "sin actividad";

    div.innerHTML = `
      <div class="userLeft">
        <span class="${u.online ? 'online-dot' : 'offline-dot'}"></span>
        <div class="userMeta">
          <div style="font-weight:bold">${u.name || id}</div>
          <div class="lastSeen">Ãšlt. actividad: ${lastSeen}</div>
        </div>
      </div>
      <div style="display:flex;align-items:center;gap:8px">
        <div id="badge-${id}"></div>
        <button data-id="${id}" class="openBtn">Abrir</button>
      </div>
    `;
    usersList.appendChild(div);

    // escuchar unread count de este usuario y actualizar badge
    const unreadRef = ref(db, `unread/${id}/count`);
    onValue(unreadRef, (uSnap) => {
      const count = uSnap.val() || 0;
      const badgeEl = document.getElementById(`badge-${id}`);
      if(!badgeEl) return;
      badgeEl.innerHTML = count > 0 ? `<span class="badge-unread">${count}</span>` : '';
      // actualizar Ø¹Ù†ÙˆØ§Ù† Ø§Ù„ØµÙØ­Ø© global badge (sumar todos)
      updateGlobalUnreadBadge();
    });

    // attach listener para nuevo mensaje en la sala (si no existe aÃºn)
    if(!unreadListeners[id]){
      const roomRef = ref(db, `chatMessages/${id}`);
      // onChildAdded => detecta mensajes nuevos
      onValue(roomRef, (roomSnap) => {
        // cuando haya nuevos mensajes, se activa onValue; para detectar solo aÃ±adidos, podemos comparar timestamps,
        // pero aquÃ­ simplificamos: contamos total y vemos el Ãºltimo mensaje
        let lastTs = 0;
        let lastMsg = null;
        roomSnap.forEach(mch => {
          const m = mch.val();
          if(m && m.timestamp && m.timestamp > lastTs){
            lastTs = m.timestamp;
            lastMsg = m;
          }
        });
        // si hay mensaje nuevo y no estamos en la sala seleccionada => incrementar unread
        if(lastMsg && lastMsg.from !== "admin"){
          // si admin NO estÃ¡ viendo esta sala => incrementar
          if(selectedUserId !== id){
            // incrementar contador unread con transaction
            const unreadCountRef = ref(db, `unread/${id}/count`);
            runTransaction(unreadCountRef, (current) => {
              return (current || 0) + 1;
            }).then(()=> {
              // mostrar notificaciÃ³n (desktop + sound + SW)
              showDesktopNotification("Nuevo mensaje", `${lastMsg.name || 'Usuario'}: ${truncateText(lastMsg.text, 80)}`);
              playSound();
              // badge global + flash
              startFlash();
            }).catch(()=>{ /* ignore */ });
          }
        }
      });
      unreadListeners[id] = true; // marque listener agregado
    }
  });

  // conectar botones "Abrir" (despuÃ©s de construir DOM)
  const openBtns = usersList.querySelectorAll(".openBtn");
  openBtns.forEach(b => {
    b.onclick = () => {
      const id = b.getAttribute("data-id");
      selectRoom(id);
    };
  });
});

// funciÃ³n helper truncar
function truncateText(s, n){
  if(!s) return "";
  return s.length > n ? s.slice(0,n-1) + 'â€¦' : s;
}

/* actualizar badge global (suma de todos unread) */
function updateGlobalUnreadBadge(){
  const allBadges = document.querySelectorAll('[id^="badge-"] .badge-unread');
  let sum = 0;
  allBadges.forEach(el => sum += parseInt(el.textContent || '0'));
  if(sum > 0){
    startFlash(sum);
  } else {
    stopFlash();
  }
  // (opcional) ÙŠÙ…ÙƒÙ†Ùƒ Ø£ÙŠØ¶Ø§Ù‹ ÙˆØ¶Ø¹ Ø±Ù‚Ù… ÙÙŠ Ø¹Ù†ÙˆØ§Ù† Ø§Ù„ØµÙØ­Ø© Ø£Ùˆ favicon
}

/* seleccionar sala */
function selectRoom(id){
  selectedUserId = id;
  // reset unread for this user
  set(ref(db, `unread/${id}/count`), 0).catch(()=>{});
  // cargar mensajes
  listenRoom(id);
  listenTyping(id);
  // actualizar tÃ­tulos
  const userName = document.querySelector(`#user-${id} .userMeta div:first-child`)?.textContent || id;
  selectedUserName = userName;
  roomTitle.textContent = `Sala: ${selectedUserName}`;
  roomSub.textContent = `Usuario: ${id}`;
  // reset local lastMessageTimestamp para evitar notificaciones duplicadas
  lastMessageTimestamp = 0;
  stopFlash();
}

/* ESCUCHAR MENSAJES DE UNA SALA */
function listenRoom(userId){
  messagesArea.innerHTML = "";
  const roomRef = ref(db, "chatMessages/" + userId);
  onValue(roomRef, (snap) => {
    messagesArea.innerHTML = "";
    let newestTs = lastMessageTimestamp || 0;
    snap.forEach(child => {
      const m = child.val();
      const d = document.createElement("div");
      d.className = "msg " + (m.from === "admin" ? "admin" : "user");
      d.innerHTML = `<span class="who">${m.from === 'admin' ? 'AdministraciÃ³n' : (m.name || 'Usuario')}</span>
                     <div>${m.text}</div>
                     <div style="font-size:11px;color:#9aa4b2;margin-top:6px">${m.timestamp ? new Date(m.timestamp).toLocaleString() : ''}</div>`;
      messagesArea.appendChild(d);
      if(m.timestamp && m.timestamp > newestTs) newestTs = m.timestamp;
    });
    messagesArea.scrollTop = messagesArea.scrollHeight;

    // establecer lastMessageTimestamp para evitar notificaciones duplicadas mientras admin estÃ© viendo la sala
    lastMessageTimestamp = newestTs;
  });
}

/* ESCUCHAR TYPING */
function listenTyping(userId){
  const tRef = ref(db, `typing/${userId}`);
  onValue(tRef, (snap) => {
    typingIndicator.textContent = snap.val()?.typing ? "â€¦estÃ¡ escribiendo" : "";
  });
}

/* ENVIAR RESPUESTA */
sendReplyBtn.onclick = async () => {
  if(!selectedUserId) return alert("Elige un usuario");
  const txt = adminReply.value.trim();
  if(!txt) return alert("Escribe la respuesta primero");
  await push(ref(db, `chatMessages/${selectedUserId}`), {
    text: txt,
    from: "admin",
    name: "AdministraciÃ³n",
    timestamp: Date.now()
  });
  // ademÃ¡sØŒ Ù†Ø¶Ø¹ unread ØµÙØ± Ù„Ø£Ù† Ø§Ù„Ù…Ø¯ÙŠØ± Ù‚Ø±Ø£/Ø±Ø¯
  set(ref(db, `unread/${selectedUserId}/count`), 0).catch(()=>{});
  // Ø­Ø°Ù typing
  set(ref(db, `typing/${selectedUserId}`), { typing: false }).catch(()=>{});
  adminReply.value = "";
  stopFlash();
};

/* BORRAR SALA */
clearRoomBtn.onclick = () => {
  if(!selectedUserId) return alert("Elige un usuario");
  if(!confirm("Â¿Eliminar todos los mensajes de esta sala?")) return;
  remove(ref(db, `chatMessages/${selectedUserId}`)).catch(()=>{});
  // reset unread
  set(ref(db, `unread/${selectedUserId}/count`), 0).catch(()=>{});
};

/* BOTÃ“N SALIR (solo informativo) */
logoutBtn.onclick = () => {
  alert("Salir no estÃ¡ activo. Esta interfaz estÃ¡ siempre abierta.");
};

/* ---------- UTILS / INICIALIZACION ---------- */

// Cuando carga la pÃ¡gina, actualizamos el badge global
updateGlobalUnreadBadge();

/*
  NOTA IMPORTANTE SOBRE "NOTIFICACIONES CUANDO LA PÃGINA ESTÃ CERRADA":
  ---------------------------------------------------------------
  - El cÃ³digo anterior muestra notificaciones y usa el Service Worker para mostrarlas
    cuando la pÃ¡gina estÃ¡ en background o abierta.
  - Para que las notificaciones lleguen cuando LA PÃGINA ESTÃ CERRADA (ventana/ pestaÃ±a no abierta)
    necesitas configurar un servicio de 'push' como Firebase Cloud Messaging (FCM).
  - Si quieres, te doy los pasos para:
      1) generar credenciales FCM
      2) conectar Realtime Database -> Cloud Function -> enviar push a los navegadores
      3) recibir esos push en este Service Worker (sw.js)
  - El fichero sw.js incluido (ver archivo aparte) ya maneja eventos 'push' y 'notificationclick'.
*/

</script>
</body>
</html>
